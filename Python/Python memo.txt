==================================
算数运算符

// 取整除， 返回除法的整数部分（商），9//2输出结果是4
** 幂，又称次方，乘方，2**3=8
在python中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果
“-” * 10

==================================
计算机三大件
1)CPU 处理数据/计算
2)内存 临时储存数据，速度快，空间小
3)硬盘 永久储存，速度慢，空间大

=================================
CPU 把python解释器程序复制到内存中
pythoon解释器根据语法规则，从上向下让CPU翻译python程序中的代码
CPU负责执行翻译完成代码

确认解释器所在位置
$which python

查看python文件大小
$ ls -lh /usr/bin/python

查看具体文件大小
$ ls -lh /usr/bin/python2.7


====================================================
变量类型
查看数据类型
$ type(variable)

变量之间的计算

字符串变量之间使用+拼接字符串
字符串变量 使用 * 重复拼接相同的字符串

变量的输入
$ variable = input('please input something')
利用input输入的内容都认为是一个字符串

类型转换
$ variable =int(input(''please input something))
$ variable =float(input(''please input something))

格式化输出
$name ='xiaoming'
$ print('my name is %s' %name)
$ student_no=00001
$ print('my student no is %05d' %student_no)
$ price =9.00
$ weight=5.00
$ money=price*weight
$ print('apple price is %.02f, weight is %.02f, payment is %.02f' %(price,weight,money))
$ scale=10.00
$ print('data scale is %.02f%%' %scale)

=========================================
逻辑运算符
and
or
not

=========================================
随机数处理
randint(a,b) [a,b]
========================================
赋值运算符
=
+=
-=
*=
/=
//=
%=
**=
============================================
break 和continue 是專門在循环中使用的关键字
break 某一个条件满足时，推出循环，不再执行后续重复的代码
continue 某一条件满足时，不执行后续重复代码
break 和continue 只针对当前所在循环有效

============================================
print("*",end='') #向控制台输出内容结束后，不会换行

============================================
使用转义字符调整格式
\\反斜杠
\' 单引号
\" 双引号
\t 输出文本保持垂直方向对齐
\n 在控制台输出一个换行符
\r 回车

===============================================

增加     list.insert(index,data)   在指定位置插入数据
        list.append(data)        在末尾追加数据
        list.extend(list2)      将list2追加到列表

修改    list[index]=data        修改指定索引的数据

删除    del list[index]         删除指定索引的数据，本质上是用来将一个变量从内存删除
        list.remove[data]      删除第一个出现的指定数据
        list.pop              删除末尾数据
        list.pop(index)       删除指定索引数据
        list.clear            清空列表

统计    len(list)             列表长度
        list.cout(data)     数据在列表中出现的次数

排序       list.sort()                 升序排序
          list.sort(reverse=True)     降序排列
          list.reverse()              逆序，反转


=====================================================
元组的元素不能修改
元组保存不同数据类型
创建tuple=()

元组本身是可以省略括号的
tuple = 1,2

索引方式用[]
元组只有一个元素的时候，这个元素后面需要一个逗号
single_tuple=(5,)
如果single_tuple=(5)，这是一个整数类型

tuple.index
tuple.count

格式化字符串本质上就是元组

list1 = [1,2,3,4]
a,*_,b = list1
是取第一个数和最后一个数

====================================================
列表和元组转换
list(tuple)
tuple(list)

======================
set.pop() 随机remove一个数

====================================================
字典
用{}定义
key是索引
value是数据
key:value
key必须是唯一的
value可以是任何数据类型，但是key只能使用字符串，数字或者元组

dict.keys() 所有key的列表
dict.value()所有value列表
dict.items()所有(key,vaue)元组列表
dict.pop(key)
len(dict) 统计key value数量
dict.update(dict2) 合并字典，注意被合并的字典中包含已经存在的key value会被覆盖
dict.clear() 清空

遍历
变量i是每次循环获得到的key
for i in dict

应用场景
使用多个key value描述一个object，然后将多个字典放在一个列表中进行遍历，在循环体内针对每个字典进行相同的处理
====================================================
字符串
最好用""来定义字符串，只有在字符串内部需要双引号时候，再用‘’

注意，所有方法不会改变原列表，会返回一个列表
len(str)
str.count("s")
str.index("s")

判断类型
string.isspace() 如果string中只包含空格，制表符，回车等空白字符，则返回True
string.isalnum() 如果string至少有一个字符并且所有字符都是字母或者数字，则返回True
string.isalpha() 如果string至少有一个字符并且字符都是字母则返回True

下面三个都不能判断小数，从上到下功能强大
string.isdecimal() 如果string只包含数字则返回True，全角数字
string.isdigit() 如果string只包含数字则返回True，全角数字，（1)，\u00b2（unicode字符串）
string.isnumeric()如果string只包含数字则返回True，全角汉字，汉字数字

string.istitle() 如果string是标题化的（每个单词的首字母大写）则返回True
string.islower()如果string中包含至少一个区分大小写的字符，并且所有这些字符都是小写，则返回True
string.isupper() 如果string中包含至少一个区别大小写的字符，并且所有这些字符都是大写，则返回False

查找和替换
string.startwith(str) 检查字符串是否以str开头，是则返回True
string.endwith(str) 检查字符串是否以str结尾，是则返回True
string.find(str, start=0,end=len(string)) 检测str是否包含在string中，如果start和end指定范围，则检查是否
包含在指定范围内，如果是，返回开始的索引值，否则返回-1
string.rfind(str,start=0,end=len(string)) 同理，只不过从右开始查找
string.index(str,start=0,end=len(string))，同上，只不过如果str不在string会报错
string.index(str,start=0,end=len(string))，同上，只不过从右边开始查找
string.replace(old_str,new_str,num=string.count(old_str)) 把string中old_str替换成new_str，如果
num指定，则替换不超过num次, replace会返回一个新字符串，但不会修改原有字符串

大小写转换
string.capitalize() 把字符串第一个字符大写
string.title() 把字符串的每个单词首字母大写
string.lower() 转换string中所有大写字符为小写
string.upper() 转换string中所有小写字符为大写
string.swapcase() 翻转大小写

去除空白字符
sting.lstrip() 截掉string左边开始的空白字符
sting.rstrip() 截掉string右边开始的空白字符
string.strip() 去掉string两边的空白字符

拆分和链接
string.partition(str) 把字符串string分成一个3元素的元组，str前面，str，str后面
string.rpartition(str) 同上，从右边查找
string.split(str="",num) 以str为分隔符切片string，如果num有指定值，仅分隔num+1个子字符串，str
默认包含'\r','\t','\n'和空格
string.splitlines() 按照'\r',\n'分隔，罚你一个包含各行作为元素的列表
string.join(seq) 以string作为分隔符，将seq中所有元素（的字符串表示）合并为一个新的字符串

==================================================
切片
适用于字符串，列表和元组

字符串[开始索引：结束索引：步长]
指定的区间属于左闭右开
从开头开始，开始索引数字可以省略，冒号不能省略
到末尾结束，结束索引数字可以省略，冒号不能省略
步长默认为1,如果连续切片，数字和冒号都可以省略
步长的正负号理解成切片左右方向，正号就是往右边切，负号就是往左边切
索引的负号代表从右边算起
num_str="0123456789"
print(num_str[-2::-1])
体会一下，这个相当于从倒数第二个往左边切，也就是说取得876543210
print(num_str[-2::1]), 取得89
==================================================
公共函数
Python 内置函数

len(item)  个数
del(item)  删除变量
max(item)  返回最大值   如果是dict，只对key比较
min(item)  返回最小值   如果是dict，只比较key

切片：字符串，列表和元组

运算符
+         [1,2] +[3,4]      [1,2,3,4]           合并          字符串，列表，元组
*         ['H']*4           ['H','H','H','H']   重复          字符串，列表，元组
in        3 in (1,2,3)      True                元素是否存在    字符串，列表，元组，字典
not in    4 not in [1,2,3]  True                元素是否不存在   同上

> >=
==        (1,2,3)<(2,2,3)   True          元素比较            字符串，列表，元组
< <=

注意，in/not in 在dict操作时对key进行操作
list.extend(list2) 是对原list进行操作
list+list2 是形成一个新列表
list.append([1,2]) 是把[1,2]当作一个元素追加到list里面

==========================================
完整for 循环语法
for var in set:
  循环体代码
else:
  没有通过break推出循环，循环结束后，会执行代码


========================================
zip & unzip

letters = ['a', 'b', 'c']
nums = [1, 2, 3]

for letter, num in zip(letters, nums):
    print("{}: {}".format(letter, num))

some_list = [('a', 1), ('b', 2), ('c', 3)]
letters, nums = zip(*some_list)

=============================================
enumerate
letters = ['a', 'b', 'c', 'd', 'e']
for i, letter in enumerate(letters):
    print(i, letter)



======================================================
关键字 后面不需要括号
函数和方法需要括号
=====================================================
变量的引用
变量中记录数据的地址，就叫做引用
用id()函数可以查看变量中保存数据所在的内存地址
注意，如果变量已经被定义，当给一个变量赋值的时候
本质上是修改了数据的引用
  变量不再对之前的数据引用
  变量改为对新赋值的数据引用

函数本质上传递的是实参保存数据的引用，而不是实参保存的数据
返回的是数据的引用，而不是数据本身

字典的key只能使用不可变类型的数据
可变类型的数据变化，是通过方法来实现的
如果给一个可变类型的变量赋值了一个新的数据，引用会修改
  变量不再对之前的数据引用
  变量改为对新赋值的数据引用

哈希(hash)
Python 内置有一个名字叫做hash(o)的函数
  接受一个不可变类型的数据作为参数
  返回结果是一个整数
哈希是一种算法，作用是提取数据的特征码（指纹)
  相同内容得到相同结果
  不同内容得到不同结果

在Python中，设置字典的键值对，首先对key进行hash 已决定如何
在内存中保存字典的数据，以方便后续对字典的操作：增，删，改，查

===============================================
在python中，在函数内部不允许直接修改全局变量的值
如果使用赋值语句，会在函数内部，定义一个局部变量

如果在函数中需要修改全局变量，需要在函数内部使用global进行声明
  $num=10
  $def demo():
  $   global num
  $   num=100
  $   print(num)

  $demo()
================================================
代码结构示意图
 shebang(使用哪个解释器)
 import 模块
 全局变量
 函数定义
 执行代码

 ============================================
函数返回多个值可以利用元组返回，同时元组小括号可以省略
看上去就像是返回多个值一样，但是类型是元组
如果函数返回的类型是元组，同时希望单独处理元组中的元素
可以使用多个变量，一次接收函数的返回结果
注意，使用多个变量接受结果时，变量的个数应该和元组中元素的个数保持一致

$ def measure():
$   temp=10
$   wetness=100
$   return temp,wetness

a,b=measure()

a,b=b,a 其实是 a,b=(b,a) 使用元组然后省略了括号

==========================================
在函数内部，针对参数使用赋值语句，不会影响调用函数时传递的
实参变量
只要针对参数使用赋值语句，会在函数内部修改局部变量
的引用，不会影响到外部变量的引用

如果传递的参数是可变类型，在函数内部使用方法修改了数据内容，
会影响到外部的数据

列表变量使用 += 不会做相加再赋值的操作
本质上是调用列表的extend的方法
这个与数值和字符串有区别

list1 是global列表变量
在调用函数中,以下两个意义不同
  list1+=list1 （调用了extend的方法，会修改global list1的值）
  list1=list1+list1（函数内部的赋值语句，不会修改global list1的值）

=========================================
缺省参数的注意事项
缺省参数的定义位置
  必须保证带有默认值的缺省参数在参数列表末尾

=======================================
多值参数
python中，两种多值参数
  参数名前增加一个*可以接受元组
  参数名前增加两个**可以接受字典
一般在给多值参数命名时，习惯使用一下两个名字
  *args 存放元组参数，前面有一个*
  **kwargs 存放字典参数，前面有两个*

args arguments的缩写
kw是 keyword的缩写，kwargs可以记忆键值对参数

def demo(num,*args,**kwargs)

demo(1,2,3,4,5,name='xiaoming',age=18)
这里 num=1, args=(2,3,4,5),kwargs={"name":"xiaoming"."age":18}

def sum_numbers(*args):
    sum=0
    for n in args:
        sum+=n
    return sum

sum=sum_numbers(2,3,3,4)

元组和字典的拆包
在调用带有多值参数的函数时，如果希望：
  将一个元组变量直接传递给args
  将一个字典变量直接传递给kwargs
就可以使用拆包，简化参数传递，拆包方式
  在元组变量前，增加一个*
  在字典变量前，增加两个**

===============================
函数的递归
递归函数的特点
一个函数内部调用自己
    函数内部可以调用其他函数，当然在函数内部也可以调用自己

代码特点
1.函数内部的代码是相同的，只是针对的参数不同，处理的结果不同
2.当参数满足一个条件时，函数不再执行
  递归的出口，否则会出现死循环

============================
dir 内置函数
利用dir()函数，可以知道对象的所有属性和方法
__方法名__格式的方法是python提供的内置方法和属性。
=============================
self
哪一个对象调用的方法，self就是哪一个对象的引用
在类封装的方法内部，self就是表示当前调用方法的对象自己
调用方法时，不需要传递self参数
在方法内部
  可以通过self.访问对象的属性
  也可以通过self.调用这个对象的其他方法

=====================================
初始化方法
当使用类名（）创建对象时，会自动执行一下操作：
  为对象在内存中分配空间--创建对象
  为对象的属性设置初始值--初始化方法（init）
这个初始化方法就是 __init__方法，__init__是对象的内置方法
__init__方法是专门用来定义一个类具有哪些属性的方法
在定义属性时，如果不知道设置什么初始值，可以设置为None
  None关键字表示什么都没有
  表示一个空对象，没有方法和属性，是一个特殊的常量
  可以将None赋值给任何一个变量


如果希望在创建对象的同时，就设置对象的属性，可以对__init__方法进行改造：
  1.希望设置的属性值，定义成__init__方法的参数
  2.在方法内部使用,self.属性=行参 接受外部传递的参数
  3.在创建对象时，使用类名（属性1,属性2...)调用

__str__方法
在python中，使用print输出对象变量，默认情况下，会输出这个变量引用的对象是由
哪一个类创建的对象，以及在内存中的地址（十六进制表示）
如果在开发中，希望使用print输出对象变量时，能够打印自定义的内容，就可以利用__str__这个内置方法
注意，__str__方法必须返回一个字符串

def __str__(self)
  return "xxx"

身份运算符
身份运算符用于比较两个对象的内存地址是否一致  是否是同一个对象的引用
在python 中针对None 比较时，建议使用is判断

is      is是判断两个标识符是不是引用同一个对象  x is y
is not  is not是判断两个标识符是不是引用不同对象  x is not y

is与==区别：
is 用于判断两个变量引用对象是否为同一个
== 用于判断引用变量的值是否相等

=============================================
私有属性和私有方法
在定义属性和方法时，在属性名和方法名前增加两个下划线
私有属性和私有方法不能被外界调用，私有属性只能被自己类方法调用
但是在python中私有属性和私有方法是伪私有，如果需要访问，_类名__名称是可以访问属性和方法的，不推荐！

==============================================
继承：子类拥有所有父类的属性和方法
class B（A）：

对父类方法进行扩展
如果在开发中，子类的方法实现中包含父类的方法实现
  父类原本封装的方法是子类方法的一部分
可以使用扩展方式
1.子类中重写父类的方法
2.在需要的位置使用 super().父类方法  来调用父类方法的执行
3.代码其他的位置针对子类的需求，编写子类特有的代码实现

子类对象不能在自己的方法内部，直接访问父类的私有属性或者私有方法
子类对象可以通过父类的共有方法间接访问私有属性或者私有方法

  私有属性和方法是对象的隐私，不能对外公开，外界以及子类都不能直接访问

多继承时，子类根据 mro顺序来查找父类方法，method resolution order

父类 要用
class A(object) 来定义，这叫新式类，如果没有写object，则叫经典类（不推荐）
python3只有新式类

=======================================
多态
以继承和重写父类方法为前提
=======================================

类属性，类也是对象
定义类属性直接在类下方使用赋值语句，定义类属性。
类属性不会用于记录具体对象的特征
通常用来记录与这个类相关的特征
class A(object):
  var=0 #类属性
  def __init__(self,name):
    self.name=name

==================================
类

访问类属性有两种：
1.类名.类属性
2.实例名.类属性（不推荐）

python解释器访问类属性利用从下向上查找
如果使用 实例.类属性=值  赋值语句， 只会给对象添加一个属性，而不会修改类属性的值


类方法和静态方法

@classmethod
def 类方法名（cls):
  pass

类方法需要用修饰器@classmethod 来标识，告诉解释器这是一个类方法
类方法的第一个参数应该是cls
  由哪一个类调用的方法，方法内的cls就是哪一个类的引用
  这个参数和实例方法的第一个参数是sefl类似
  提示使用其它名称也可以，不过习惯使用cls
通过类名，调用类方法，调用方法时，不需要传递cls参数
在方法内部
  可以通过cls.访问类的属性
  也可以通过cls.调用其他的类方法


  class Tool(object):
      count=0
      def __init__(self,name):

          self.name = name
          Tool.count += 1  #要非常注意这个变量的定义

      @classmethod
      def show_tool_count(cls):
          print("create %s instance" %cls.count)


静态方法，如果方法 不访问实例属性，也不访问类属性，那就可以定义成静态方法

@staticmethod
def 静态方法（）：
  pass

静态方法需要修饰器 @staticmethod 来标识，告诉解释器这是个静态方法，不需要传递self参数
通过 类名. 调用静态方法， 不需要创建对象！！！

=============================================
单例是指实例只会有一个，创建对象只会用一块内存

使用 类名（） 创建对象时，python 的解释器首先会调用 __new__ 方法为对象分配空间
__new__ 是一个由 object 基类提供的内置的静态方法，主要作用有两个：
  在内存中嗯为对象分配空间
  返回对象的引用

python解释器获得对象的引用后，将引用作为第一个参数， 传递给 __init__方法
重写 __new__ 方法的代码非常固定

重写 __new__方法一定要  return super().__new__(cls)
否则python 的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法
注意：__new__是一个静态方法，在调用时，需要主动传递 cls 参数

class A(object):
  instance =None
  def __new__(cls,*args,**kwwargs):

    if cls.intance is None:

      cls.instance = super().__new__(cls) #这个是用了object这个基类的__new__方法
    return cls.instance


__new__方法流程:

cls.instance is None? ->no -> return cls.instance
      |
      V
      yes-> cls.instance=super().__new__(cls)


只执行一次初始化工作
在每次使用 类名（）创建对象时，python解释器都会自动调用两个方法：
  __new__分配空间
  __init__对相互实话
参考上半部分，每次都会得到第一次被创建对象的引用
但是 初始化方法还会被再次调用
如果只想执行一次初始化
解决办法

1.定义一个类属性 init_flag 标记是否执行过初始化，初始值为False
2.在__init__ 方法中，判断 init_flag,如果 False，就执行初始化动作
然后将 init_flag 设置为True
再次调用时就不会被执行

=================================================
异常
在程序开发中，对某些代码的执行不能确定是否正确，可以增加 try 来捕获异常
捕获异常最简单的语法格式:
try:
  执行代码
except expression # 可以使用python 异常最后一行的第一个单词:
  出现错误的处理

捕获未知错误
  如果希望程序无论出现任何错误，都不会因为python 解释器抛出异常而被终止，可以再增加一个except

except Exception as result:
  执行代码


异常捕获完整语法

  try:
    #尝试执行的代码
    pass
  except 错误类型1:
    #针对错误类型1,对应的代码处理
    pass

  except （错误类型2,错误类型3）:
    #针对错误类型2,3 对应的代码处理
    pass

  except Exception as result:
    #未知错误，打印错误信息

  else：
    #没有异常才会执行的代码
    pass

  finally：
    #无论是否有异常，都会执行的代码

异常的传递
异常的传递 -- 当函数/方法 执行出现异常，会将异常传递给函数/方法的 调用一方
如果 传递到主程序，仍然没有异常处理，程序才会被终止

在开发中，可以在主函数中增加异常捕获
而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中
这样就不需要在代码中，增加大量的异常捕获，能够保证代码的整洁性


抛出异常
根据应用程序特有的业务需求 主动 抛出异常

python 提供了一个 Exception 异常类
如果希望主动抛出异常，可以：
  创建一个Exception 的对象
  使用 raise 关键字 抛出 异常对象

  def A（）：
    。。。。
    。。。。
    ex = Exception(*args) #创建异常实例
    raise ex

然后在主程序中捕获异常
  try:
    执行code
  except Exception as result:
    执行code
==========================================================
模块
导入模块时，每个导入应该独占一行
import 模块名1 as 模块别名
from 模块名1 import 工具名  # 注意如果两个模块，存在同名函数，后导入模块的函数，会覆盖掉先导入的函数
一旦发生冲突，用as起别名名

from 模块名1 import *
这个不需要 模块名1. 的方式， 不过不推荐使用

给文件起名，不要和系统的模块文件重名，因为pyton搜索模块先在当前目录搜索，然后去系统搜索

模块名.__file__ 可以确认模块路径

开发原则， 每一个文件都应该是可以被导入的
在导入模块时，模块中的所有没有任何缩进的代码都会被执行一遍

在导入模块时，提供全局变量，函数，类，注意：模块内直接执行的代码不是向外提供的工具
所以，模块中能够直接执行的代码不需要被执行

__name__属性
  __name__属性可以做到，测试模块的代码只在测试情况下被运行，而在被导入时不会被执行
__name__是python的一个内置属性，记录着一个字符串
如果是被其他文件导入的， __name__就是模块名
如果是当前执行的程序 __name__是 __main__
所以，在当前模块执行一些code时候，利用 if __name__=="__main__" 来作为前提，当该模块被其他文件导入时
这些code不会被执行
  # 导入模块
  # 定义全局变量
  #定义类
  #定义函数

  def main()：
    #
    pass

  #根据__name__判断是否执行下方代码
  if __name__=="__main__":
    main()

===========================================
包
包是一个包含多个模块的特殊目录
目录下有一个特殊文件  __init__.py
包名的命名方式和变量名一致，小写字母 + _

好处：使用 import 包名，可以一次性导入包中所有模块

先建立一个文件夹，里面放一个__init__.py的文件，然后放入其他python 文件

__init__.py
#从当前目录导入模块列表
$ from . import xxx1
$ from . import xxx2
===============================================
文件的基本操作

打开文件
读写
关闭文件

python中操作文件需要1个函数和3个方法

1. open 打开文件，并且返回文件操作对象
2. read 将文件内容读取到内存
3. write 将指定内容写入文件
4. close 关闭文件

open函数负责打开文件，并且返回文件对象
read/write/close 三个方法都需要通过文件对象来调用

open 函数默认以 只读方式 打开文件，并且返回文件对象
$ f = open ("文件名"， “访问方式”)
访问方式      说明
r           以只读方式打开文件。文件的指针将会放在文件的开头，这是默认方式，如果文件不存在，抛出异常
w           以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件
a           以追加方式打开文件。如果该文件已经存在，文件指针会放在文件结尾。如果文件不存在，创建新文件进行写入
r+          以读写方式打开文件。文件的指针将会放在文件的开偶。如果文件不存在，抛出异常
w+          以读写方式打开。如果文件存在会被覆盖。如果文件不存在，创建新文件
a+          以读写方式打开文件。如果文件存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入

频繁移动文件指针，影响文件读写效率，开发更多以只读，只写来操作文件


readline
read 方法 默认会把文件的所有你容一次性读取到内存
文件太大，对内存占用严重

readline 方法
file = open（"xxx"）
while True:
  text = file.readline()

  if not text：
    break
  print (text)

file.close()

可以创建迭代的方式
file_a = open ('',r)
iter(lambda: file_a.read(1024),b'')


==============================================
文件/目录的常用管理操作
在python中，实现创建，重命名，删除，改变路径，查看目录内容，需要导入 os 模块

文件操作

rename  重命名文件  os.name(源文件名，目标文件名)
remove  删除文件    os.remove(文件名)

listdir 目录列表    os.listdir(目录名)
mkdir   创建目录    os.mkdir（目录名）
rmdir   产出目录    os.rmdir(目录名)
getcwd  获取当前目录  os.getcwd（）
chdir   修改工作目录  os.chdir(目标目录)
path.isdir  判断是否是文件 os.path.isdir(文件路径)
文件/目录都支持相对和绝对路径
======================================

UTF-8 编码格式
计算机 使用1-6字节表示一个字符

=========================================
eval 函数 将字符串当成有效的表达式来求值 并返回计算结果

eval("1+1") 转换成 1+1,输出结果是2

  $input_str = input("请输入一个算术题：")
  $print(eval(input_str))
